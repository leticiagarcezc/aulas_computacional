[
["index.html", "ESTATÍSTICA COMPUTACIONAL Disciplina ministrada à alunos do bacharelado em estatística da UFPB", " ESTATÍSTICA COMPUTACIONAL Disciplina ministrada à alunos do bacharelado em estatística da UFPB Docente: Prof. Dr. Pedro Rafael Diniz Marinho E-mail: pedro.rafael.marinho@gmail.com / pedro@de.ufpb.br Perído Letivo: 2019.1 Última atualização: 31/05/2019 Departamento de Estatística (UFPB): http://www.de.ufpb.br/ Licença O material Estatística Computacional do Prof. Pedro Rafael. D. Marinho está licenciado com uma Licença Creative Commons - Atribuição-NãoComercial-CompartilhaIgual 4.0 Internacional. Isso quer dizer: Você tem o dirieto de copiar e redistribuir o material em qualquer suporte ou formato; Você tem o direito de remixar, transformar e criar a partir deste material; Você deve dar crédito apropriado, fornecer um link para a licença e indicar se foram feitas alterações. Você pode fazê-lo de qualquer maneira razoável, mas de nenhuma maneira que sugira que o licenciador endossa você ou seu uso; Você não poderá utilizar o material para fins comerciais; Se você remixar, transformar, ou criar a partir do material, tem de distribuir as suas contribuições sob a mesma licença que o original. Sendo assim, não poderá aplicar termos jurídicos ou medidas de caráter tecnológico que restrinjam legalmente outros de fazerem algo que a licença permita. Maiores detalhes a respeito da licença em: https://creativecommons.org/licenses/by-nc-sa/4.0/. Observação: Os códigos que estão presentes nesse material está sobre os termos GNU General Public License (\\(\\geq 3\\), versão três ou superior). Assim, o leitor poderá fazer uso de qualquer código desse material em seus projetos, pacotes, desde que cite a fonte. Importante: Esse material está sob constante aprimoramento e sugestões poderão ser enviadas para o repositório do GitHub que hospeda o conteúdo ou mesmo por e-mail. Uma vez que o material está sendo mantido e versionado no GitHub, as alterações podem ser realizadas diretamente no arquivo fonte do projeto, bastando clicar no ícone no formato de um lápis, no canto superior esquerdo desta página, ou das páginas em que se desejam sugerir alterações como correções de palavras, mudanças de parágrafos, alteração de códigos, melhoramento de exemplos, inclusão de novos exemplos, etc. As alterações serão bem vindas e serão acatadas (incorporadas ao arquivo orignal) a medida que forem julgadas como sendo convenientes. Nota: Para que que seja possível propor alterações é necessário que a pessoa saiba utilizar o git/GitHub e tenha realizado um fork do trabalho em sua conta do GitHub. Trataremos do uso do git e GitHub no início desse material. "],
["prefacio.html", "Prefácio Tecnologias abordadas no curso Teorias abordadas no curso Sugestões de passos para revisão da linguagem R", " Prefácio Esse material sempre tentará se adequar à ementa da disciplina de Estatística Computacional, sendo esta uma disciplina obrigatória do curso de bacharelado em estatística do Departamento de Estatística da UFPB. Dessa forma, trata-se de um material destinado à alunos do Departamento de Estatística da UFPB. Porém, esse material poderá vir a despertar interesse à outras pessoas que não alunos da instituição. A ementa do curso de Estatística Computacional que compõe a estrutura do curso como disciplina obrigatória poderá ser obtida no link. Como pode-se observar, a disciplina é dividida no uso de tecnologias (linguagem de marcação e linguagem de programação) e alguns aspectos teóricos que envolvem a teoria da estatística computacional. O bom uso dos conceitos abordados no curso estará alinhado ao perfeito entendimento das tecnologias e teorias apresentadas. O tópico referente à tipografia científica em LaTeX não será abordado, visto que esse assunto atualmente está sendo apresentado na disciplina de Metodologia do Trabalho Científico no início do curso. Além disso, o tópico referente à programação em R abordará aspectos mais avançados da linguagem, uma vez que a essa altura do curso, os alunos entendem os conceitos básicos da linguagem R. Sendo assim, esse não é o material adequado para você, caso o seu enteresse seja aprender a linguagem de programação R. Em um futuro próximo, quando este material estiver concluído e caso você já considere um usuário avançado de R, talvez pular para os assuntos referentes à estatística computacional venha ser mais produtivo para o seu aprendizado. Tecnologias abordadas no curso Uso de git e GitHub para versionamento de projetos; Linguagem de programação R sob um olhar mais avançado: Orientação à objeto utilizando funções genéricas (sistema S3 de orientação à objeto); Sistema R6 de orientação à objeto; Expressões regulares (regex); Uso de funcionais. Nessa parte será revisado os funcionais do base r bem como serão apresentados novos funcionais; Construção de pacotes em R; Uso de pacotes que incorporam características novas à linguagem R, entre eles, alguns dos pacotes da comunidade do RStudio; Conceitos de metaprogramação. Linguagem de marcação: LaTeX; Linguagem de marcação: markdown; Checando a peformance do código e identificando gargalos; Closures; Paralelismo em R (OpenMP). Em substituição ao item 2, trataremos do rmardkown, em especial, do uso do pacote bookdown para a construção de relatórios e livros dinâmicos utilizando a linguagem de marcação markdown. Por exemplo, esse material foi construído utilizando essas ferramentas. Nota: Um bom material em lingua portuguesa sobre o LaTeX poderá ser obtido no link. Teorias abordadas no curso Geração de números pseudo-aleatórios: Método da inversão; Método da aceitação-rejeição; Método da transformação. Métodos de Monte Carlo; Métodos de reamostragem: Jackknife; Bootstrap: para estimação de erro-padrão de um estimador, correção de viés, construção de intervalos aleatórios, testes de hipóteses, bootstrap de Wu (bootstrap selvagem). Algumas dessas metodologias serão apresentadas em esquemas simples (um nível de bootstrap) e duplo (dois níveis de bootstrap). Métodos de otimização não-linear em estatística: métodos de Newton e quasi-Newton. Sugestões de passos para revisão da linguagem R É aconselhado que antes de prosseguir nesse material o leitor faça uma revisão básica da linguagem R. Entre os princiapis conceitos necessários para uma boa progressão nesse curso, destacam-se: Entenda as diferenças de funcionamento de um compilador para um interpretador. Lembre-se, R é uma linguagem interpretada; Revise os principais tipo de dados: character, double, integer e logical. Lembre-se que por regra de coerção, os tipos mais flexíveis em R seguem a seguinte regra de flexibilidade: character &gt; double &gt; integer &gt; lógico. Isso quer dizer, por exemplo, que a é um vetor que possui elemtendos do tipo character e double, então todos os elementos do vetor serão coagidos para o tipo mais flexível, nesse caso o tipo character. Exemplo: a &lt;- c(1, letters[1:5]); is.character(a[1]) retornará TRUE. Lembre-se que R não possui constantes. Constantes são tratadas como vetores atômicos de comprimento 1. Esses são chamados de atômicos por se a estrutura básica da linguagem, uma vez que R é uma linguagem vetorial; Por falar em vetores atômicos / vetores, revise as principais estruturas de dados em: vetores atômicos (c()), fatores (factor()), listas (list()), matrizes (matrix()), sequência de matrizes (arrays()), tabelas (data.frames()). Note que uma matriz é um array de comprimento 1. Não confunda estrutura de dados com tipo de dados. Estruturas de dados refere-se ao mecanismo de organização de dados, já o tipo de dados refere-se ao tipo básico das informações que são organizadas nas estruturas de dados; Entenda o uso das funções is.troque() e as.troque(), em que troque poderá ser ser substituido por: Um Estrutura de dados: vector, factor, list, numeric, data.frame, matrix, array. Um Tipos de dados: integer, double, numeric, character e logical. Revise os operadores relacionais e lógicos: Operadores Relacionais: ==(igual), &lt; (menor), &lt;= (menor ou igual), &gt; (maior), &gt;= (maior ou igual), != (diferente); Operadores Lógicos: || (OU lógico), &amp;&amp; (E lógico), ! (NÃO lógico). Esses são operadores não vetorizados. Versões vetorizadas serão abordadas no decorrer do curso. Revise as estruturas de condições: if, else, switch, ifelse. A função ifelse equivale à estrutura (condição) ? retorno 1 : retorno 2 das linguagens C/C++; Revise as estruturas de repetições: while, for e repeat. Entenda o uso das instruções break e next quando utilizadas dentro dessas estruturas. Revise a construção de funções em R. Tente entender a flexibilidade embutida em funções que retornam uma lista. Se achar necessário, revise algumas funções úteis: ls(), rm(), length(), sum(), abs(), mean(), median(), var(), sd(), cor(), summary(), sqrt(), exp(), expm1() (fornece uma boa proximação para exp(x) - 1, quando x é pequeno), log(), log10(), log1p() (fornece uma boa aproximação para log(x+1) quando x é pequeno), round(), union(), intersect(), choose(), factorial(), dim(), ncol(), nrow(), diag(), %*%, t(), solve(), det(), eigen(), print(), cat(), paste(), paste0(), substring(),str(), sort(), quantile(), match() e %in%. Lembre-se que quando os operadores +, -, *, /, %% (módulo / resto da divisão) e ^ são aplicados ente matrizes, ou entre matrizes e vetores de comprimento 1 (“constantes”), as operações serão realizadas elemento à elemento. Diversas outras características da linguagem R são importantes e serão lembradas aos poucos na medida que for necessário. Ficará a cargo do leitor fazer as sugestões de revisões acima. O capítulo que inicia esse material é dedicado à apresentação de exercício em que o leitor deverá resolver. Trata-se de um capítulo em que os exercícios envolvem as sugestões de revisão da linguagem R apresentadas acima. Os exercícios para serem resolvidos poderão exigir revisões de outros conceitos que não foram listados na proposta de revisão acima. No entanto, se esses exercícios forem bem resolvidos, utilizando-se de boas práticas de programação em R, a leitura desse material será a mais agradável possível. "],
["revisao-basica-da-linguagem-r.html", "1 Revisão básica da linguagem R Exercícios propostos", " 1 Revisão básica da linguagem R Mesmo que você se considere um programador razoável de R, aconselho que venha resolver a lista de exercícios apresentada adiante. É comum que venhamos esquecer de alguns conceitos de linguagens em que programamos. Esses exercícios é uma oportunidade que você irá ter de revisar lógica de programação utilizando a linguagem R e consequentemente revisar alguns conceitos importantes, porém básicos, da linguagem. Tente resolver esses exercícos após um olhar detalhado das sugestões apresentadas. A lista de assuntos para revisão sugerem temas bastante simples para quem já programa um pouco na linguagem R. Tais sugestões aliadas com as resoluções desses exercício irão lapidar os conhecimentos necessários e fará com que você necessariamente revise outros assuntos inseridos nos exercícios. Estes assuntos/exercícios também são simples e não envolverão conceitos avançados da linguagem R. Conceitos mais avançados serão abordados no decorrer do curso de Estatística Computacional e exercícios estarão disponíveis no decorrer de outros capítulos, à medida que forem necessários. Observação: A google disponibilizou um guia de estilo de programação em R. Trata-se de um guia de boas práticas de programação, no que diz respeito à escrita do código. Esse guia não trata de boas práticas de programação para a obtenção de melhorias de desempenho da linuguagem R. Você não é obrigado adotar essas normas. Porém, segui-las tornará o seu código mais legível. Exercícios propostos Descreva o funcionamento e as diferenças de um compilador para um interpretador. Liste exemplos de linguagens de programação compiladas e interpretadas. Responda os itens abaixo: Descreva os principais tipos de dados da linguagem R. Descreva as principais estruturas de dados da linguagem R. Disserte sobre as diferenças entre tipos de dados e estruturas de dados. Descreva quais estruturas de dados são homogêneas e quais estruturas são heterogêneas. Explique o por quê das saídas abaixo: x &lt;- c(7.1, 2.3, 3L, TRUE) x ## [1] 7.1 2.3 3.0 1.0 y &lt;- c(TRUE, letters[1:3]) y ## [1] &quot;TRUE&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; z &lt;- c(1.0, 5, 7, 0L) z ## [1] 1 5 7 0 Sem utilizar o R, o que você espera como retorno de x &lt;- c(1, c(2, c(3, 4))); x. Qual a estrutura de dados de x? Irá ocorrer erro ao tentar criar um vetor atômico (vetor) com objetos de tipos diferentes? Como o interpretador de R trata essas situações. Explique detalhadamente. O que signicica NA, NaN, Inf e -Inf, em R? Liste algumas das situações em que utilizando-se das operações básicas +, -, * e / poderemos ter NaN como retorno. Considere vetor &lt;- c(2, 7, 10, 8). Qual o tipo de dados do objeto vetor? Crie os objetos vetor_int, vetor_character e vetor_logical. Dica: crie esses objetos utilizando funções para conversão dos tripos dos elementos do objeto vetor. O que faz o código abaixo? Explique detalhadamente o que cada função faz. objects(grep(&quot;bas&quot;, search())) Qual o retorno do código abaixo? Explique detalhadamente o código. search()[(grep(&quot;gr&quot;, search()))] Forneça o código que acessa o caracter \"a\" de l, em que l &lt;- c(list(c(3, 2), \"a\"), c(1,2)). Depois, converta l em um vetor atômico. Sem executar os códigos abaixo, descreva as saídas esperadas: Qual a saída esperada para os códigos c(1, FALSE), c(\"a\", 1), c(list(1), \"a\"), c(TRUE, 1L)? Por que 1 == \"1\" retornará TRUE? Explique. Por que -1 &lt; FALSE retornará TRUE? Explique. Considere o objeto vetor &lt;- 1:25. Com o objeto vetor, construa uma matriz de ordem 5x5 usando a função matrix() e depois utilizando a função dim(). Crie a matriz M, de ordem 50x50, com elementos de 1 à 2500 preenchidos por linha. Atribua nomes às linhas (l_1 à l_50) e colunas (c_1 à c_50) de M. Dica: certamente você percebeu que não será nada interessante digitar os nomes das linhas e colunas de M. Tente utilizar as funções paste() e rep()como soluções para esse problema. Remova os nomes das linhas e colunas da matriz M criada no exercício anterior. Sejam V1 &lt;- matrix(1:12, ncol = 4, nrow = 3) e W1 &lt;- matrix(1:8, ncol = 4, nrow = 2). Crie a matriz M1que é o resultado da concatenação, por linha, de V1 e W1. Considere os objetos V2 &lt;- matrix(1:12, ncol = 2, nrow = 4) e W2 &lt;- matrix(1:12, ncol = 3, nrow = 4). Cria a matriz M2como resultados da concatenação, por coluna, de V2 e W2. Considere obj &lt;- list(1:3, \"a\" , TRUE, 1.0). Construa uma matriz de ordem 2x2 a partir de obj. O que de interessante você observa? Construa a matriz A (matriz de avaliações), de ordem 30x2, em que a primeira coluna são os nomes dos alunos (Aluno_1 à Aluno_30) e a segunda coluna são as notas de 3 avaliações, por aluno. Dica: para facilitar, gere as avaliações dos alunos de forma aleatória. O que a função dim() retorna quando aplicada à um vetor? Se is.matrix(x) retorna TRUE, o que irá retornar de is.array(x)? Explique. Descreva os objetos objetos x1, x2 e x3 construídos na forma apresentada abaixo: x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) Considere o código apresentado abaixo: df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df$y ## [1] a b c ## Levels: a b c Qual a estrutura de dados de df$y? Como poderemos alterar o comportamento do data frame df para que df$y retorne um vetor atômico com elementos do tipo character? Ao tentar criar um data frame com o código abaixo obteremos um erro. Corrija o código: data.frame(x = 1:3, y = list(1:2, 1:3, 1:4)) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 2, 3, 4 Considere a lista abaixo: notas &lt;- list(c(7.1, 3.2, NA), c(2.7, 8.8, 10.0), c(0.0, NA, NA), c(7.7, 8.4, 6.3), c(3.6, 6.6, 8.1), c(NA, NA, NA), c(7.4, 7.1, 7.3), c(10.0, NA, 7.0), c(1.6, 3.2, 5.3), c(8.8, 9.2, 8.0)) Responta os itens abaixo: Atribua nomes (Aluno_1 à Aluno_10) à cada elemento de notas. Crie o vetor status contendo o status dos dez alunos. Considere: A (aprovado), REP (reprovado), F (final). Dica: construa o vetor status atribuindo literalmente as categorias A, REP ou F para cada aluno, ou seja, não é preciso criar uma função para fazer isso automaticamente. Considere A para os alunos com média no intervalo \\([7, 10]\\), R para os alunos com média no intervalo \\([0, 4)\\) e F para os alunos com média no intervalo \\([4, 7)\\). Crie o vetor alunos com os nomes dos alunos. Obtenha esse vetor por meio do objeto notas. Construa o data frame historico com as variáveis nomes, notas e status. Com base no data frame historico, construa o data frame aprovados com os alunos aprovados. De forma análoga, construa um data frame para cada um dos demais status, respectivamente. Suponha que o professor está interessado em saber quais alunos foram ou tem alguma chance de assumir o status de aprovado. Construa o data frame bons_alunos com estes alunos. Modifique os nomes das linhas do data frame historico colocando id_1 na primeira linha e respectivamente, no mesmo padrão, para as demais linhas. Obtenha por meio do data frame historico um novo data frame (historico_na) com os alunos que deixaram ao menos uma prova para repor. Apenas para os alunos que fizeram as três avaliações, obtenha a média aritmética das avaliações. Acrescente a variável de nome media como última coluna do data frame historico. Consideremos o conjunto de dados state.x77 do pacote datasets (pacote padrão de R). A base state.x77 refere-se à um objeto de ordem 50x8, em que cada linha refere-se à um dos 50 estados dos EUA. Consulte a documentação (help(state.x77)) para obter maiores informações. Responda os itens abaixo: Qual a estrutura de dados do objeto state.x77? Construa o data frame dados utilizando state.x77. Obtenha o data frame de nome dados_1 com os estados estadunidenses que possuem população maior que 4246 (quatro milhões duzentos e quarenta e seis mil). Obtenha o data frame dados_2 com os estatdos estadunidenses que possuem população maior que 4246 e menor que 8 milhões, isto é, menor que 8000. Obtenha o vetor vetor_est com os nomes dos estados que obedecem os critérios do item 3. Construa o data frame dados_3 com os estados estadunidenses que possuem população maior que 1.5 vezes a média dos 50 estados considerados. Obtenha um vetor com o nome dos estados que obedecem essa restrição. Construa o data frame dados_4 com os estados estadunidenses que possuem população maior que duas vezes a mediana dos 50 estados e que tenha uma população com expectativa de vida maior que 71.84 anos. Obtenha o data frame dados_5 com os estados estadunidenses cuja população possuem renda maior que a média nacional e expectativa de vida maior que 72 anos. Adicione ao data frame dados duas linhas com as médias e variâncias de todas as variáveis, respectivamente. Escreva um programa que retorne a saída baixo: i1 = 1 i2 = 2 i3 = 3 i4 = 4 i5 = 5 i6 = 6 i7 = 7 Dica: Resolva esse simples exercício de três formas diferentes (usando while, for e repeat). Escreva uma função que retorne o imposto pago por mulheres e por homens, sabendo que as mulheres pagam \\(10\\%\\) e que os homens pagam \\(5\\%\\) a mais do que as mulheres. Resolva o exercício anterior utilizando a função switch(). Implemente a função tab(num, inicio, fim) que é responsável por escrever no prompt de commando a tabuada de um número passado como argumento à num. Nota: os argumentos inicio e fim referem-se ao início e fim da tabuada, ou seja, tab(num = 1, inicio = 7, fim = 12) deverá escrever no prompt: 1 x 7 = 7 1 x 8 = 8 1 x 9 = 9 1 x 10 = 10 1 x 11 = 11 1 x 12 = 12 Implemente tab() utilizando as diferentes escruturas de repetição da linguagem R (for, while e repeat). Escreva a função celtofar() que converte um vetor de temperaturas em graus Celsius para graus Fahrenheit. Considere: \\[F = 1.8 \\times C + 32,\\] em que \\(C\\) é a temperatura em graus Celsius e \\(F\\) é a temperatura em graus Fahrenheit. Melhore a função celtofar() para que critique valores não válidos de temperaturas. Modifique a função celtofar() para que funcione também para conversões no sentido oposto, isto é, para que converta de graus Fahrenheit para graus Celsius. Construa a função imc() que calcula o IMC (Índice de Massa Corporal) de uma pessoa. A função deverá retornar o IMC e um status. Observe que: \\[\\mathrm{IMC} = \\frac{\\mathrm{peso}}{\\mathrm{altura}^2},\\] em que \\(\\mathrm{peso}\\) é dado em \\(kg\\) e a \\(\\mathrm{altura}\\) é fornecida em \\(cm\\). Alem disso, considere: IMC Status \\(&lt; 17.0\\) Muito abaixo do peso \\([17.0, 18.5)\\) Abaixo do peso \\([18.5, 25.0)\\) Peso normal \\([25.0, 30.0)\\) Acima do peso \\([30.0, 35.0)\\) Obesidade nível I \\([35.0, 40.0)\\) Obesidade nível II (severa) \\(\\geq 40.0\\) Obesidade nível III (mórbida) Dica: Uma função robusta deverá tratar problema(s) com a(s) entrada(s), isto é, deverá criticar informações inconsistentes passadas como argumento. Utilizando a instrução de repetição for construa um pequeno programa que com base em um vetor de valores no intervalo \\([0, 1]\\), some apenas os valores maiores que 0.7. Dica: para economizar tempo, considere vetor &lt;- runif(n = 1e5, min = 0, max = 1). Resolva o exercício anterior sem utilizar nenhuma instrução de repetição. Avalie o custo computacional dos exercícios anteriores (exercícios 34 e 35) utilizando a função Sys.time(). Discuta o resultado. Construa a função central(x) que recebe como argumeto um vetor passado à x e retorna algumas medidas de tendência central. A função central() deverá retornar: Média aritmética (média amostral): \\(\\overline{x} = n^{-1}\\sum_{i = 1}^n x_i.\\) Média geométrica: \\(G = (\\prod_{i=1}^n x_i)^{\\frac{1}{n}}.\\) Média harmônica: \\(H = \\frac{n}{\\frac{1}{x_1} + \\cdots + \\frac{1}{x_n}}.\\) Algumas exigências a respeito do funcionamento da função central() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as três medidas de tendência central ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário da função deverá ser emitida informando-o a repseito do número de observações eliminadas e em quais posições encontravam-se estas observações. 3 - A função deverá alertar o usuário se uma estrutura/tipo de dados não suportado por central() for passado como argumento à x. A função deverá alertar qual estrutura/tipo de dados foi passado, avinsando assim que essa estrutura/tipo de dados não poderá vir a ser processado(a). Nota: Não utilize a vetorização da linguagem R. Nesse exercício desejamos treinar o uso das estruturas de repetições da linguagem. Não utilizar vetorização da linguagem quer dizer que você não poderá aplicar uma função à todos elementos de um vetor. Por exemplo, se x é um vetor, você não poderá fazer x^2, sqrt(x), mean(x), length(), etc. Aplique a função a cada posição do vetor utilizando estruturas de repetições. Em seus projetos reais, utilize a capacidade de vetorização da linguagem e evite o quanto der as estruturas de repetições. Isso fará com que os seus códigos sejam mais eficientes. Aqui apenas queremos exercitar o uso das estruturas de repetições. Além disso, central() poderá ter outros argumentos além de x. Sem utilizar a capacidade de vetorização da linguagem R, nas formas do exercício anterior, implemente a função myvar(x) que retorna a variância amostral de um vetor passado como argumetno à x. Algumas exigências a respeito do funcionamento da função myvar() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as três medidas de dispersão ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário deverá ser passada informando o número de observações eliminadas e em quais posições encontravam-se. 3 - A função deverá alertar o usuário se uma estrutura ou tipo de dados não coerente com o interesse da função for passado como argumento à x. Nota: Não utilize a vetorização da linguagem R. Nesse exercício desejamos treinar o uso das estruturas de repetições da linguagem. Não utilizar vetorização da linguagem quer dizer que você não poderá aplicar uma função à todos elementos de um vetor. Por exemplo, se x é um vetor, você não poderá fazer x^2, sqrt(x), mean(x), length(), etc. Aplique a função a cada posição do vetor utilizando estruturas de repetições. Em seus projetos reais, utilize a capacidade de vetorização da linguagem e evite o quanto der as estruturas de repetições. Isso fará com que os seus códigos sejam mais eficientes. Aqui apenas queremos exercitar o uso das estruturas de repetições. Além disso, myvar() poderá ter outros argumentos além de x. Se x, na função myvar(), for um vetor não numérico? E se x for um vetor de caracteres numéricos? E se x for uma string numérica como \"1,2,3\" que desejamos tratar como sendo o c(1, 2, 3)? Modifique a função myvar() para que venham tratar/considerar essas situações. Implemente a função disp(x) que deverá retornar uma das medidas de dispersão listadas logo abaixo: Amplitude: \\(A = x_{\\mathrm{max}} - x_{\\mathrm{min}}.\\) Variância amostral: \\(S^2 = \\frac{\\sum_{i=1}^{n}(x_i - \\overline{x})^2}{n-1}.\\) Desvio padrão amostral: \\(S = \\sqrt{S^2}.\\) Coeficiente de variação: \\(CV = \\frac{100 \\times S}{\\overline{x}}.\\) Algumas exigências a respeito do funcionamento da função disp() encontram-se enumeradas abaixo: 1 - A função deverá retornar todas as quatro estatísticas ou apenas uma das estatísticas, a depender do interesse do usuário. 2 - Observações Not Availables NA serão eleminadas do cálculo. Porém, uma mensagem de aviso ao usuário deverá ser passada informando o número de observações eliminadas e em quais posições encontravam-se. 3 - A função deverá alertar o usuário se uma estrutura ou tipo de dados não coerente com o interesse da função for passado como argumento à x. Nota: Não utilize a vetorização da linguagem. Nesse momento também desejamos treinar o uso das estruturas de repetições da linguagem. Implemente a função mycor(x, y, pearson = TRUE, rm.na = TRUE) que deverá receber como argumentos dois vetores passados para x e y, respectivamente. A função mycor() deverá retornar o coeficiente de correlação de Pearson se pearson = TRUE, caso contrário, retornará o coeficiente de correlação de Spearman. Além disso, se rm.na = TRUE, a função mycor() deverá eliminar os Not Availables NA dos respectivos vetores. Por exemplo, se x &lt;- c(1, 8, -1, NA, NA) e y &lt;- c(NA, 7, -2, 10, 5) forem passados para mycor(), esta deverá eliminará as duas últimas observações de x e y, bem como a primeira observação de x e y, resultando, nesse exemplo, em x &lt;- c(8, -1) e y &lt;- c(7, -2), respectivamente. A função deverá alertar a respeito das eliminações e informar quais as posições eliminadas dos vetores. Algumas outras exigências a respeito do funcionamento da função mycor() encontram-se enumeradas abaixo: 1 - A função deverá parar e alertar o usuário nas situações em que os vetores não tenham os mesmos comprimentos. 2 - A função deverá retornar dois objetos, rho e level, em que rho (\\(\\rho\\)) é o valor da correlação e level informa o nível dessa correlação. Os níveis possível a ser retornados são: desprezível se \\(\\rho \\in [0, 0.3)\\), fraca se \\(\\rho \\in [0.3, 0.5)\\), moderada se \\(\\rho \\in [0.5, 0.7)\\), forte se \\(\\rho \\in [0.7, 0.9)\\) e fortíssima se \\(\\rho \\in [0.9, 1]\\). Dica: A função warning() pode ser útil para emitir uma mensagem de aviso (alerta) ao usuário da função mycor(). Construa duas funções, tree1() e tree2(), que escrevam, no prompt de comando, as imagens abaixo, respectivamente. O programa deverá utilizar instruções de repetições para resolver o problema. A primeira função deverá imprimir: ********** ********* ******** ******* ****** ***** **** *** ** * A segunda função deverá imprimir: *-*-*-*-*- *-*-*-*-* *-*-*-*- *-*-*-* *-*-*- *-*-* *-*- *-* *- * Implemente as funções utilizando as estruturas de repetições for, while e repeat. Escreva a função tree3(), utilizando instruções de repetições, de modo a fornecer as seguintes estruturas, adepender do valor de n. Para \\(n = 1\\): * Para \\(n = 2\\): * ** Para \\(n = 3\\): * ** *** e assim por diante para outros valores de \\(n\\). Implemente tree3() utilizando as estruturas de repetições for, while e repeat. Melhore as funções tree1(), tree2() e tree3() de modo que estas possam considerar caracteres distintos e não somento o caracter asterisco. Modifique a função tree1(), de tal forma que a estrutura obtida seja: Para \\(n = 1\\): A Para \\(n = 2\\): A BB Para \\(n = 3\\): A BB CCC e assim por diante para outros valores de \\(n\\). Dica: Note que \\(n \\leq 26\\). Assim, retorne uma mensagem de advertência se um valor de \\(n\\) inapropriado for informado. Dica: utilize a função stop(). Implemente a função aprox_e() que retorna uma aproximação para \\(\\mathrm{e}^x\\), em que: \\[\\mathrm{e}^x = \\sum_{n = 0}^{\\infty} \\frac{x^n}{n!}.\\] Dica: A função aprox_e() deverá receber como argumento o número de somas a serem consideradas. Crie a função aprox_pi(), fazendo uso de instruções de repetição, que forneça uma aproximação para o valor da constante \\(\\pi\\). Essa aproximação deverá considerar: \\[\\pi = 4 - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\frac{4}{9} - \\frac{4}{11} + \\dots\\] Dica: Premita que o usuário de sua função forneça a quantidade de termos a serem somados. Além disso, faça com que sua função critique valores indevidos para a quantidade de termos somados. Implemente a função fib(), utilizando instruções de repetição, que retorna o Fibonacci de um número. Lembre-se, a sequência de Fibonacci é dada por \\(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\ldots\\) . Note que Fibonacci de \\(n\\) é dado por \\(F_n = F_{n-1} + F_{n-2},\\, n &gt; 2\\), com \\(F_1 = 1\\) e \\(F_2 = 1\\). Por exemplo, Fibonacci de 5 é dado por \\(F_5 = F_{4} + F_{3} = 3 + 2 = 5\\). Implemente o exercício anterior usando funções recursivas. Lembre-se: chamamos de funções recursivas as funçãos que chamam a si mesma. Um esboço de função recursiva: func_f &lt;- function(...){ # Ué? ... # Sim! Estamos chamando a função que estamos criando. ;) func_f(...) # Será preciso parar em algum momento # somos finitos :) if (contition) break } Implemente a função aprox_pi() de forma recursiva. Implemente a função nachange(df), em que df recebe um data frame/matriz. A função nachange() deverá trocar NA pelo character “?”. Dica: Em caso de df não possuir nenhum elemento NA, a função nachange() deverá retornar o objeto passado à df. Construa a função searchindf(df, value), em que df é um data frame/matriz e value é um vetor de uma única posição. A função searchindf()deverá retorna TRUE se o valor passado para value é encontrado em alguma posição do data frame/matriz passado(a) para df e FALSE caso contrário. Dica: tente construir a função da forma mais robusta possível. Por exemplo, considere criticar os argumentos, caso estes não tenham a estrutura de dados adequada ao objetivo da função. Construa a função namecolsort(df), em que df receberá como argumento um(a) data frame/matriz. A função namecolsort() deverá retorna o(a) data frame/matriz com as colunas ordenadas. Dica: ordene as colunas considerando o primeiro caracter que compõe o nome da coluna (variável). Escreva a função exclusive(df), em que df receberá como argumento um(a) data frame/matriz. A função exclusive() deverá retornar a posição das linhas exclusivas, ou seja, as linhas que não possuem elementos repetidos. Escreva uma função extremeindex(df, max = NULL), em que df receberá como primeiro argumento um(a) data frame/matriz. A função maxindex() deverá retornar a posição (linha, coluna) do valor máximo contido no objeto passado para df, caso max = TRUE. Em caso de max = FALSE, a função maxindex() deverá retornar a posição (linha, coluna) do valor mínimo contido no objeto passado à df. Para o caso de max = NULL (caso padrão), a função maxindex() deverá retornar uma matriz de ordem 2x2, em que cada linha deverá retornar a posição do elemento mínimo e máximo, respectivamente, contidos no objeto passado à df. Implemente a função myt(df), em que dfrecebe como argumento um(a) data frame/matriz. A função myt() deverá “girar”, em 90 graus, a(o) matriz/data frame passado à df. Dica: não utilize a função t() para transpor a matriz. Crie a função anagram(x, y) que recebe dois argumentos (duas strings). A função anagram() deverá retornar TRUE se uma palavra (string) é anagrama da outra e FALSE em situação contrária. A função deverá considerar que ambas as strings possuem a mesma quantidade de caracteres. Caso a quantidade de caracteres não seja igual, em ambas as strings, a função deverá parar e advertir o usuário. Dica: você poderá utilizar a função strsplit(). Implemente a função strposition(x), em que dado uma palavra (string) fromada por letras do alfabeto Romano e passada como argumento para x, retorna a posição das letras em um vetor. Por exemplo, a string (palavra) cada passada para a função fará com que strposition() retorne o vetor formados pelos elementos 3, 1, 4 e 1. Dica: a função não poderá aceitar strings que são formadas por pelo menos um caracter que não seja uma letra do alfabeto Romano. Altere a função strposition(x) para que em situação da string (palavra) possuir um ou mais caracteres não pertencentes ao alfabeto Romano, o retono seja NA, nas respectivas posições destes caracteres. "],
["evangelizando-para-o-uso-do-gnulinux.html", "2 Evangelizando para o uso do GNU/Linux 2.1 Um breve histórico 2.2 Vantagens em utilizar GNU/Linux 2.3 Algumas distribuições 2.4 Equivalência de progamas entre diferentes SO", " 2 Evangelizando para o uso do GNU/Linux Nesse capítulo tentarei o convencer, sem imposições, que o uso de alguma distribuição GNU/Linux poderá ser um caminho coerente e que tratá facilidades para quem deseja um sistema operacional flexível, fácil de manter e livre. Tentarei aqui expressar minhas experiências no uso do linux na estatística e irei sugerir distribuições GNU/Linux que considero interessantes. Observação: Você é livre para escolher o sistema operacional (SO) ao qual deseja trabalhar. Porém, em situações em que seja necessário dissertar sobre alguma configuração específica do SO (não serão muitas), as explicações apresentadas levarão em consideração apenas sistemas GNU/Linux. 2.1 Um breve histórico Em meados de 1970, o Unix foi e nos dias de hoje ainda é um dos sistemas operacionais mais amplamente utilizados em mainframes devido à sua ampla confiabilidade, distribuição e suporte. Muitos desses sistemas Unix se tratavam de sistemas proprietários. Entre os sistemas Unix mais populares e livres estava o Berkley Software Distribution (BSD) cujo desenvolvimento (1977 e 1995) era realizado pela Computer Systems Research Group (CSRG) vinculado à Universidade da Califórnia em Berkely. Nota: Nos dias de hoje, o termo BSD é utilizado para designar qualquer sistema operacional do tipo Unix (sistemas Unix-like). Muitas vezes o termo Unix-like é substituído por UN*X ou *nix. Tratam-se de sistemas operacionais baseados em Unix mas que não necessariamente estão de acordo com a especificação Single UNIX. O sistema Linux (kernel) foi baseado no Unix, sendo este o sistema Unix-like mais popular dentre diversos outros que são razoavelmente conhecidos pelo público em geral e bastante conhecidos por profissionais que tem alguma afinidade com a computação. A maioria dos sistemas BSD’s disponíveis na atualidade possuem o código fonte aberto, porém fazem o uso da licença BSD que é menos restritiva, permitindo a distribuição somente dos arquivos binários. Trata-se de uma licença atraente para aplicativos embarcados, em que empresas não estão obrigadas a disponibilizar o código fonte das aplicações, quando estes forem solicitados. Devido a licença BSD ser menos restritivas que a licença GNU General Public License, utilizada pelo Linux, alguns sistemas BSD’s conhecidos possuem código proprietário. Muito provavelmente se você solicitar os códigos às empresas que os construíram o seu pedido não será atendido. Entre os sistemas operacionais proprietários mais conhecidos, destacam-se dois: 1 - O Solaris, nas suas primeiras versões chamado de SunOS e desenvolvido pela Sun Microsystems que em 2009 foi adquirida pela Oracle Corporation. Detalhes a respeito do sistema Solaris podem ser encontrados no site da Oracle. 2 - O Mac OS X, sistema operacional produzido pela empresa Apple. Muito provavelmente o Mac OS X é o *nix mais amplamente utilizado em PCs. Porém, o Mac OS X está longe de ser o sistema *nix mais amplamente utilizados em super computadores. Saindo do território dos sistemas BSD’s proprietários, abaixo listo alguns dos mais conhecidos sistemas BSD’s em que os códigos dos projetos são abertos, isto é, com iniciativas Open Source: 1 - FreeBSD: Trata-se de um sistema moderno e livre bastante utilizado em servidores, desktops e plataformas embarcadas. O FreeBSD é talvez o sistema BSD, de código livre, que é mais amplamente utilizado entre os sistemas dessa lista. A melhor forma de acompanhar as novidades do FreeBSD é acompanhar o FreeBSD Journal, um jornal livre dos desenvolvedores do FreeBSD. Seu mascote genérico é o BSD daemon, apelidado de Beastie. 2 - NetBSD: Trata-se de uma derivação do sistema 4.4BSD da Universidade da California, Berkley e do 386BSD, às vezes chamado de Jolix. Assim como o FreeBSD, o NetBSD é um sistema que pode rodar em diversas arquiteturas de computadores. O seu logo é uma bandeirola. 3 - OpenBSD: Trata-se de um projeto baseado no sistema 4.4BSD. O projeto OpenBSD desenvolveu aplicações como o OpenSSH que é a principal ferramenta de conectividade para login remoto utilizando o protocolo Secure Shell (SSH). O seu mascote é o Puffy. 4 - DragonFly BSD: Os seus desenvolvedores afirmam que trata-se de um sistema operacional pertencente à mesma classe de outros sistemas baseados em BSD e Linux, incluindo recursos que o diferenciam de outros sistemas operacionais da mesma classe. Por exemplo, o DragonFly BSD é o HAMMER, um moderno sistema de arquivos de alta peformance descata-se como a mais proeminente diferença. O mascote do projeto é uma libélula. Observação: Linux é uma marca registrada de Linus Torvalds. Você poderá ver essa informação aqui. Além disso, Linux é um *nix, UN*X ou Unix-like (como queira chamar) mas Linux não é um BSD nem um BSD é um Linux. Por exemplo, a biblioteca C do BSD é baseada nos códigos de Berkeley e não na GNU C Library. O sistema operacional Linux foi inicialmente desenvolvido pelo engenheiro de software Linus Torvalds em 1991. Nessa época, Linus Torvalds era discente na Universidade de Helsinque, Finlândia como estudante de ciência da computação. Sua dissertação de mestrado intitulada Linux: a Portable Operating System (56 páginas) foi defendida no Departamento de Ciência da Computação da Universidade de Helsinque, em 31 de janeiro de 1997. A dissertação introduz problemas de protabilidade do kernel Linux em diferentes arquiteturas de computadores. O autor comenta que quem acompanhou os primórdios do desenvolvimento do kernel Linux, o título de sua dissertação poderia soar como ironia, uma vez que o projeto original do Linux não estava realmente preocupado com a portabilidade do sistema em diversas arquiteturas de processadores. À época, a preocupação maior do projeto era com a execução do Linux em computadores com processadores Motorola 68k Amiga e Atari, ambos de 32 bits. Isso restringia o uso de Linux em algumas arquiteturas de PCs doméstricos da época. Atualmente o desenvolvimento do kernel Linux possuem colaborações de diversos programadores ao redor do mundo, em que Linus Torvalds é o pricipal desenvolvedor e gerencia o rumo em que o projeto deverá seguir. Aqui você poderá acessar a conta oficial do Linus Torvalds no GitHub. Você poderá acompanhar todas as modificações e quando estas foram incluídas no projeto Linux. Mais adiante nesse material trataremos a respeito do uso do git/GitHub. Por sinal, o git foi criado pelo Linus Torvalds. 2.2 Vantagens em utilizar GNU/Linux 2.3 Algumas distribuições 2.3.1 Uma sugestão pessoal 2.4 Equivalência de progamas entre diferentes SO "],
["ides-de-programacao-em-r.html", "3 IDEs de programação em R", " 3 IDEs de programação em R "]
]
