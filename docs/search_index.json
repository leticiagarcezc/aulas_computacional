[
["exercicios-para-uma-revisao-da-linguagem-r.html", "1 Exercícios para uma revisão da linguagem R Exercícios propostos", " 1 Exercícios para uma revisão da linguagem R Mesmo que você se considere um programador razoável de R, aconselho que venha resolver a lista de exercícios apresentada adiante. É comum que venhamos esquecer de alguns conceitos de linguagens em que programamos. Esses exercícios é uma oportunidade que você irá ter de revisar lógica de programação utilizando a linguagem R e consequentemente revisar alguns conceitos importantes da linguagem. Tente fazer esses exercícos após um olhar detalhado das sugestões apresentadas. As sugestões de revisão sugerem temas bastante simples para quem já programa um pouco na linguagem R. Tais sugestões aliadas com as resoluções desses exercício irão lapidar os conhecimentos necessários e fará com que você necessariamente revise outros assuntos inseridos nos exercícios. Observação: A google disponibilizou um guia de estilo de programação em R. Trata-se de um guia de boas práticas de programação no que diz respeito à escrita do código. Esse guia não trata de boas práticas de programação para a obtenção de melhorias de desempenho da linuguagem R. Você não é obrigado adotar essas normas. Porém, segui-las tornará o seu código mais legível. Exercícios propostos Responda os itens abaixo: Descreva os principais tipos de dados de R. Descreva os principais estruturas de dados de R. Disserte sobre as diferenças entre tipos de dados e estruturas de dados. Descreva quais estruturas de dados são homogêneas e quais estruturas são heterogêneas. Explique o por quê das saídas abaixo: x &lt;- c(7.1, 2.3, 3L, TRUE) x ## [1] 7.1 2.3 3.0 1.0 y &lt;- c(TRUE, letters[1:3]) y ## [1] &quot;TRUE&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; z &lt;- c(1.0, 5, 7, 0L) z ## [1] 1 5 7 0 Sem utilizar o R, o que você espera como retorno de x &lt;- c(1, c(2, c(3, 4))); x. Qual a estrutura de dados de x? Irá ocorrer erro ao tentar criar um vetor atômico (vetor) com objetos de tipos diferentes? Como o interpretador de R trata essas situações. Explique detalhadamente. O que signicica NA, NaN, Inf e -Inf, em R? Liste algumas das situações em que utilizando-se das operações básicas +, -, * e / é possível ter como retorno NaN. Considere vetor &lt;- c(2, 7, 10, 8). Qual o tipo de dados do objeto vetor? Crie os objetos vetor_int, vetor_character e vetor_logical. (Dica: Crie esses objetos fazendo a conversão do objeto vetor). O que faz o código abaixo? Explique detalhadamente o que cada função faz. objects(grep(&quot;bas&quot;, search())) Explique passo a passo a sintaxe abaixo: search()[(grep(&quot;gr&quot;, search()))] Forneça o código que acessa o caracter \"a\" de l, em que l &lt;- c(list(c(3, 2), \"a\"), c(1,2)). Depois, converta l em um vetor atômico. Sem correr os códigos abaixo, descreva as saídas obtidas: Qual a saída esperada para os códigos c(1, FALSE), c(“a”, 1), c(list(1), “a”), c(TRUE, 1L)? Por que 1 == \"1\" é igual à TRUE? Por que -1 &lt; FALSE é igual à TRUE? Considere vetor &lt;- 1:25. Com no objeto vetor, construa uma matriz de dimensão 5x5 usando a função matrix() e dois utilizando a função dim(). Crie a matriz M, de dimensão 50x50, com elementos de 1 à 2500 preenchidos por linha. Atribua nomes às linhas (l_1 à l_50) e colunas (c_1 à c_50) da matriz. (Dica: certamente você percebeu que não é nada interessante digitar elemento por elemento para as linhas e colunas da matriz. Tente utilizar as funções paste() e rep()como soluções para o problema). Remova os nomes das linhas e colunas da matriz M criada no exercício anterior. Sejam V1 &lt;- matrix(1:12, ncol = 4, nrow = 3) e W1 &lt;- matrix(1:8, ncol = 4, nrow = 2). Crie a matriz M1que é o resultado da concatenação por linha de V1 e W1. Considere os objetos V2 &lt;- matrix(1:12, ncol = 2, nrow = 4) e W2 &lt;- matrix(1:12, ncol = 3, nrow = 4). Cria a matriz M2como resultados da concatenação por coluna de V2 e W2. Considere obj &lt;- list(1:3, \"a\" , TRUE, 1.0). Construa uma matriz de dimensão 2x2 a partir de obj. Construa uma matriz de avaliações A a de dimensão 30x2, em que a primeira coluna são os nomes dos alunos (Aluno_1 à Aluno_30) e a segunda coluna são as notas de 3 avaliações, por aluno. Dica: Para facilitar, gere as avaliações dos alunos de forma aleatória. O que a função dim() retorna quando aplicada à um vetor? Se is.matrix(x) retorna TRUE, o que irá retornar de is.array(x)? Descreva os objetos objetos x1, x2 e x3. x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) Considere o código código abaixo: df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df$y ## [1] a b c ## Levels: a b c Como podemos observar, df$y retorna um fator com os níveis construídos das strings que compõe a variável y. Como podemos alterar o comportamento do data frame df para que df$y retorne um vetor atômico do tipo character? Corrija o código abaixo de modo a que venha funcionar: data.frame(x = 1:3, y = list(1:2, 1:3, 1:4)) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 2, 3, 4 Considere a lista abaixo: notas &lt;- list(c(7.1, 3.2, NA), c(2.7, 8.8, 10.0), c(0.0, NA, NA), c(7.7, 8.4, 6.3), c(3.6, 6.6, 8.1), c(NA, NA, NA), c(7.4, 7.1, 7.3), c(10.0, NA, 7.0), c(1.6, 3.2, 5.3), c(8.8, 9.2, 8.0)) Responta os itens abaixo: Atribua nomes (Aluno_1 à Aluno_10) à cada elemento de notas. Crie o vetor status contendo o status dos dez alunos. Considere: A (aprovado), REP (reprovado), F (final). (Dica: Construa o vetor status atribuindo literalmente as categorias A, REP ou F para cada aluno, ou seja, não é preciso criar uma função para fazer isso automaticamente. Considere A para os alunos com média no intervalo \\([7, 10]\\), R para os alunos com média no intervalo \\([0, 4)\\) e F para os alunos com média no intervalo \\([4, 7)\\)). Crie o vetor alunos com os nomes dos alunos. Construa o data frame historico com as variáveis nomes, notas e status. Com base no data frame historico, construa o data frame aprovados com os alunos aprovados. De forma análoga para os demais status. Suponha que o professor está interessado em saber quais alunos foram ou tem alguma chance de assumir o status de aprovado. Construa o data frame bons_alunos com estes alunos. Modifique os nomes das linhas do data frame historico colocando id_1 na primeira linha e respectivamente, no mesmo padrão, para as demais linhas. Obtenha por meio do data frame historico um novo data frame (historico_na) com os alunos que deixaram ao menos uma prova para repor. Apenas para os alunos que fizeram as três avaliações, obtenha uma média aritmética das avaliações. Acrescente a variável de nome media no data frame historico. Consideremos o conjunto de dados state.x77 do pacote datasets (pacote padrão de R). A base state.x77 refere-se à uma matriz de dimensão 50x8 em que cada linha refere-se à um dos 50 estados dos EUA. Consulte as documentações para obter maiores informações. Responda os itens abaixo: Construa o data frame dados utilizando state.x77. Obtenha um data frame de nome dados_1 com as observações de dados que possua população maior que 4246, isto é, com os estados estadunidenses que possua uma população maior que 4246 (quatro milhões duzentos e quarenta e seis mil). Obtenha o data frame dados_2 com as observações população maior que 4246 e menores que 8 milhões, isto é, menor que 8000. Obtenha o vetor vetor_est com os nomes dos estados que obedecem os critérios do item 3. Construa o data frame dados_3 com os estados estadunidenses com população maior que 1.5 vezes a média dos 50 estados considerados. Obtenha o vetor com o nome dos estados que obedecem essa regra. Construa o data frame dados_4 com os estados estadunidenses com população maior que duas vezes a mediana dos 50 estados e que tenha uma população com expectativa de vida maior que 71.84 anos. Obtenha o data frame dados_5 com os estados estadunidenses com renda maior que a média nacional, expectativa de vida maior que 72 anos. Adicione ao data frame dados duas linhas com a média de todas as variáveis e variâncias, respectivamente. Escreva uma função que retorne o imposto pago por mulheres e por homens, sabendo que as mulheres pagam \\(10%\\) e que os homens pagam \\(5%\\) a mais do que as mulheres. Resolva o exercício anterior utilizando a função switch(). Escreva a função celtofar() que converte um vetor de temperaturas em graus Celsius para graus Fahrenheit. Considere: \\[F = 1.8 * C + 32,\\] em que \\(C\\) é a temperatura em graus Celsius e \\(F\\) é a temperatura em graus Fahrenheit. Melhore a função celtofar() para que critique valores não válidos de temperatura. Modifique a função celtofar() para que funcione também para conversões no sentido oposto, isto é, converta de graus Fahrenheit para graus Celsius. Construa a função imc() que calcula o IMC (Índice de Massa Corporal) de uma pessoa. A função deverá retornar o IMC e um status. Observe que: \\[\\mathrm{IMC} = \\frac{\\mathrm{peso}}{\\mathrm{altura}^2},\\] em que \\(\\mathrm{peso}\\) é dado em \\(kg\\) e a \\(\\mathrm{altura}\\) é fornecida em \\(cm\\). Alem disso, considere: IMC Status \\(&lt; 17.0\\) Muito abaixo do peso \\([17.0; 18.5)\\) Abaixo do peso \\([18.5; 25.0)\\) Peso normal \\([25.0; 30.0)\\) Acima do peso \\([30.0; 35.0)\\) Obesidade nível I \\([35.0; 40.0)\\) Obesidade nível II (severa) \\(\\geq 40.0\\) Obesidade nível III (mórbida) Dica: Uma função robusta deverá tratar problemas com a entrada, isto é, deverá criticar informações inconsistentes passadas como argumento. Escreva um programa que retorne a saída baixo: i1 = 1 i2 = 2 i3 = 3 i4 = 4 i5 = 5 i6 = 6 i7 = 7 Dica: Resolva esse simples exercício de três formas diferentes (usando while, for e repeat). Utilizando a instrução de repetição for construa um pequeno programa que com base em um vetor de valores no intervalo \\([0, 1]\\), some apenas os valores maiores que 0.7. Dica: Para economizar tempo, faça vetor &lt;- runif(n = 1e5, min = 0, max = 1) para gerar o objeto vetor. Resolva o exercício 28 sem utilizar nenhuma instrução de repetição. Avalie o custo computacional dos exercícios anteriores (exercícios 28 e 29) utilizando a função Sys.time(). Discuta o resultado. Construa duas funções que escrevam as imagens abaixo, respectivamente. O programa deverá utilizar instruções de laço de resolver o problema. A primeira função deverá imprimir: ********** ********* ******** ******* ****** ***** **** *** ** * A segunda função deverá imprimir: *-*-*-*-*- *-*-*-*-* *-*-*-*- *-*-*-* *-*-*- *-*-* *-*- *-* *- * Escreva um programa em R, utilizando as instruções de loop vistas anteriormente, de modo a fornecer as seguintes estruturas, adepender do valor de n. Para \\(n = 1\\): * Para \\(n = 2\\): * ** Para \\(n = 3\\): * ** *** e assim por diante para outros valores de \\(n\\). Dica: crie uma função tree() que tenha n como argumento. Resolva o exercício anterior acrescentando mais um argumento à função tree() para que seja possível especificar outro caracter além de *. Modifique o programa da solução do exercício 31, de tal forma que a estrutura obtida seja: Para \\(n = 1\\): A Para \\(n = 2\\): A BB Para \\(n = 3\\): A BB CCC e assim por diante para outros valores de \\(n\\). Dica: Note que \\(n \\leq 26\\). Assim, retorne uma mensagem de advertência se um valor de \\(n\\) inapropriado for informado. Por exemplo, utilize a função stop(). Implemente a função aprox_e() que retorna uma aproximação para \\(\\mathrm{e}^x\\) considerando: \\[\\mathrm{e}^x = \\sum_{n = 0}^{\\infty} \\frac{x^n}{n!}.\\] Dica: A função aprox_e() deverá receber um argumento em que será utilizado como o número de termos somados. Crie a função aprox_pi(), fazendo uso de instruções de repetição, que implemente a aproximação abaixo para o valor da constante \\(\\pi\\): \\[\\pi = 4 - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\frac{4}{9} - \\frac{4}{11} + \\dots\\] Dica: Premita que o usuário de sua função forneça a quantidade de termos a ser considerado na soma. Além disso, faça com que sua função critique valores indevidos para a quantidade de termos somados. Implemente a função fib(), utilizando instruções de repetição, que retorna o Fibonacci de um número. Lembre-se, a sequência de Fibonacci é dada por \\(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\ldots\\) . Note que Fibonacci de \\(n\\) é dado por \\(F_n = F_{n-1} + F_{n-2},\\, n &gt; 2\\), com \\(F_1 = 1\\) e \\(F_2 = 1\\). Por exemplo, Fibonacci de 5 é dado por \\(F_5 = F_{4} + F_{3} = 3 + 2 = 5\\). Implemente o exercício anterior usando funções recursivas. Lembre-se: chamamos de funções recursivas a função que chama a si mesma. Um esboço: func_f &lt;- function(...){ # Ué? ... # Sim! Estamos chamando a função que estamos criando. ;) func_f(...) # É preciso para em algum momento # somos finitos :) if (contition) break } Implemente a função aprox_pi() de forma recursiva. Implementa a função nachange(df), em que df recebe um data frame / matriz. A função nachange() deverá trocar NA pelo character “?”. Dica: Em caso de df não possuir nenhum elemento NA, a função nachange() deverá retornar o objeto passado para df. Construa a função searchindf(df, value), em que df é um data frame / matriz e value é um vetor de uma única posição. A função searchindf()deverá retorna TRUE se o valor passado para value é encontrado em alguma posição do data frame passado para df e FALSE caso contrário. Dica: Tente construir a função de forma mais robusta possível. Por exemplo, considere criticar os argumentos caso estes não sejam de estrutura de dados correta. Você não poderá utilizar funções já implementadas em R para esse finalidade. Construa a função namecolsort(df), em que df recebe como argumento um data frame/matriz. A função namecolsort() deverá retorna o data frame / matriz com as colunas ordenadas. Dica: Ordene as colunas considerando o primeiro caracter do nome da coluna. Escreva a função exclusive(df), em que dfrecebe como argumento um data frame/matriz. A função exclusive() deverá retornar a posição das linhas exclusivas, ou seja, as linhas que não possuem elementos repetidos. Escreva uma função extremeindex(df, max = TRUE), em que dfrecebe como primeiro argumento um data frame/matriz. A função maxindex() deverá retornar a posição (linha, coluna) do valor máximo no objeto passado para df, caso max = TRUE. Em caso de max = FALSE, a função maxindex() deverá retornar a posição (linha, coluna) do valor mínimo no objeto passado para df. Dica: A função maxindex() deverá retornar um vetor em que o primeiro elemento refere-se à linha e o segundo informa a coluna do elemento encontrado (máximo/mínimo). Implemente a função myt(df), em que dfrecebe como argumento um data frame/matriz. A função myt() deverá girar em 90 graus a matriz/data frame passado para df. Dica: Não utilize a função t() para transpor uma matriz. Crie a função anagram(x, y) que recebe dois argumentos (duas strings). A função anagram() deverá retornar TRUE se uma palavra (string) é anagrama da outra e FALSE em situação contrária. A função deverá considerar que ambas as strings possui a mesma quantidade de caracteres. Caso a quantidade de caracteres não seja igual em ambas as strings, a função deverá parar e advertir o usuário. Dica: Você poderá utilizar a função strsplit(). Implemente a função strposition(x) que dado uma palavra (string) fromada por letras do alfabeto Romano e passada como argumento para x, retorne a posição das letras em um vetor. Por exemplo, a string (palavra) cada passada para a função fará com que strposition() retorne o vetor formados pelos elementos 3, 1, 4 e 1. Dica: A função não poderá aceitar strings que são formadas por pelo menos um caracter que não seja uma letra do alfabeto Romano. Altere a função strposition(x) para que em situação da string possuir um ou mais caracteres não pertencentes ao alfabeto Romano, o retono sejaNA, nas respectivas posições destes caracteres. "]
]
