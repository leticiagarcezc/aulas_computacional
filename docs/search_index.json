[
["index.html", "ESTATÍSTICA COMPUTACIONAL Disciplina ministrada para os alunos do bacharelado em estatística da UFPB", " ESTATÍSTICA COMPUTACIONAL Disciplina ministrada para os alunos do bacharelado em estatística da UFPB Docente: Prof. Dr. Pedro Rafael Diniz Marinho E-mail: pedro.rafael.marinho@gmail.com / pedro@de.ufpb.br Perído Letivo: 2019.1 Última atualização: 28/05/2019 Departamento de Estatística (UFPB): http://www.de.ufpb.br/ Licença O trabalho Estatística Computacional de Prof. Pedro Rafael. D. Marinho está licenciado com uma Licença Creative Commons - Atribuição-NãoComercial-CompartilhaIgual 4.0 Internacional. Isso quer dizer: Você tem o dirieto de copiar e redistribuir o material em qualquer suporte ou formato; Você tem o direito de remixar, transformar e criar a partir deste material; Você deve dar crédito apropriado, fornecer um link para a licença e indicar se foram feitas alterações. Você pode fazê-lo de qualquer maneira razoável, mas de nenhuma maneira que sugira que o licenciador endossa você ou seu uso; Você não poderá utilizar o material para fins comerciais; Se você remixar, transformar, ou criar a partir do material, tem de distribuir as suas contribuições sob a mesma licença que o original. Sendo assim, não poderá aplicar termos jurídicos ou medidas de caráter tecnológico que restrinjam legalmente outros de fazerem algo que a licença permita. Maiores detalhes a respeito da licença em: https://creativecommons.org/licenses/by-nc-sa/4.0/. Observação: Os códigos que estão presentes nesse material está sobre os termos GNU General Public License (\\(\\geq 3\\), versão três ou superior). Assim, o leitor poderá fazer uso de qualquer código desse material em seus projetos, pacotes, desde que cite a fonte. Importante: Esse material está sob constante aprimoramento e sugestões poderão ser enviadas para o repositório do GitHub que hospeda o conteúdo ou mesmo por e-mail. Uma vez que o material está sendo mantido e versionado no GitHub, as alterações podem ser realizadas diretamente no arquivo fonte do projeto, bastando clicar no ícone no formato de um lápis, no canto superior esquerdo desta página, ou das páginas em que se desejam sugerir alterações como correções de palavras, mudanças de parágrafos, alteração de códigos, melhoramento de exemplos, inclusão de novos exemplos, etc. As alterações serão bem vindas e serão acatadas (incorporadas ao arquivo orignal) a medida que forem julgadas como sendo convenientes. Nota: Para que que seja possível propor alterações é necessário que a pessoa saiba utilizar o git/GitHub e tenha realizado um fork do trabalho em sua conta do GitHub. Trataremos do uso do git e GitHub no início desse material. "],
["prefacio.html", "Prefácio Tecnologias abordadas no curso Teorias abordadas no curso Sugestões de passos para revisão da linguagem R", " Prefácio Esse material sempre tentará se adequar à ementa da disciplina de Estatística Computacional, sendo esta uma disciplina obrigatória do curso de bacharelado em estatística do Departamento de Estatística da UFPB. Dessa forma, trata-se de um material destinado à alunos do Departamento de Estatística da UFPB. Porém, esse material poderá vir a despertar interesse à outras pessoas que não alunos da instituição. A ementa do curso de Estatística Computacional que compõe a estrutura do curso como disciplina obrigatória poderá ser obtida no link. Como pode-se observar, a disciplina é dividida no uso de tecnologias (linguagem de marcação e linguagem de programação) e alguns aspectos teóricos que envolvem a teoria da estatística computacional. O bom uso dos conceitos abordados no curso estará alinhado ao perfeito entendimento das tecnologias e teorias apresentadas. O tópico referente à tipografia científica em LaTeX não será abordado, visto que esse assunto atualmente está sendo apresentado na disciplina de Metodologia do Trabalho Científico no início do curso. Além disso, o tópico referente à programação em R abordará aspectos mais avançados da linguagem, uma vez que a essa altura do curso, os alunos entendem os conceitos básicos da linguagem R. Sendo assim, esse não é o material adequado para você, caso o seu enteresse seja aprender a linguagem de programação R. Em um futuro próximo, quando este material estiver concluído e caso você já considere um usuário avançado de R, talvez pular para os assuntos referentes à estatística computacional venha ser mais produtivo para o seu aprendizado. Tecnologias abordadas no curso Uso de git e GitHub para versionamento de projetos; Linguagem de programação R sob um olhar mais avançado: Orientação à objeto utilizando funções genéricas (sistema S3 de orientação à objeto); Sistema R6 de orientação à objeto; Expressões regulares (regex); Uso de funcionais. Nessa parte será revisado os funcionais do base r bem como serão apresentados novos funcionais; Construção de pacotes em R; Uso de pacotes que incorporam características novas à linguagem R, entre eles, alguns dos pacotes da comunidade do RStudio; Conceitos de metaprogramação. Linguagem de marcação: LaTeX; Linguagem de marcação: markdown; Checando a peformance do código e identificando gargalos; Closures; Paralelismo em R (OpenMP). Em substituição ao item 2, trataremos do rmardkown, em especial, do uso do pacote bookdown para a construção de relatórios e livros dinâmicos utilizando a linguagem de marcação markdown. Por exemplo, esse material foi construído utilizando essas ferramentas. Nota: Um bom material em lingua portuguesa sobre o LaTeX poderá ser obtido no link. Teorias abordadas no curso Geração de números pseudo-aleatórios: Método da inversão; Método da aceitação-rejeição; Método da transformação. Métodos de Monte Carlo; Métodos de reamostragem: Jackknife; Bootstrap: para estimação de erro-padrão de um estimador, correção de viés, construção de intervalos aleatórios, testes de hipóteses, bootstrap de Wu (bootstrap selvagem). Algumas dessas metodologias serão apresentadas em esquemas simples (um nível de bootstrap) e duplo (dois níveis de bootstrap). Métodos de otimização não-linear em estatística: métodos de Newton e quasi-Newton. Sugestões de passos para revisão da linguagem R É aconselhado que antes de prosseguir nesse material o leitor faça uma revisão básica da linguagem R. Entre os princiapis conceitos necessários para uma boa progressão nesse curso, destacam-se: Entenda as diferenças de funcionamento de um compilador para um interpretador. Lembre-se, R é uma linguagem interpretada; Revise os principais tipo de dados: character, double, integer e logical. Lembre-se que por regra de coerção, os tipos mais flexíveis em R seguem a seguinte regra de flexibilidade: character &gt; double &gt; integer &gt; lógico. Isso quer dizer, por exemplo, que a é um vetor que possui elemtendos do tipo character e double, então todos os elementos do vetor serão coagidos para o tipo mais flexível, nesse caso o tipo character. Exemplo: a &lt;- c(1, letters[1:5]); is.character(a[1]) retornará TRUE. Lembre-se que R não possui constantes. Constantes são tratadas como vetores atômicos de comprimento 1. Esses são chamados de atômicos por se a estrutura básica da linguagem, uma vez que R é uma linguagem vetorial; Por falar em vetores atômicos / vetores, revise as principais estruturas de dados em: vetores atômicos (c()), fatores (factor()), listas (list()), matrizes (matrix()), sequência de matrizes (arrays()), tabelas (data.frames()). Note que uma matriz é um array de comprimento 1. Não confunda estrutura de dados com tipo de dados. Estruturas de dados refere-se ao mecanismo de organização de dados, já o tipo de dados refere-se ao tipo básico das informações que são organizadas nas estruturas de dados; Entenda o uso das funções is.troque() e as.troque(), em que troque poderá ser ser substituido por: Um Estrutura de dados: vector, factor, list, numeric, data.frame, matrix, array. Um Tipos de dados: integer, double, numeric, character e logical. Revise os operadores relacionais e lógicos: Operadores Relacionais: ==(igual), &lt; (menor), &lt;= (menor ou igual), &gt; (maior), &gt;= (maior ou igual), != (diferente); Operadores Lógicos: || (OU lógico), &amp;&amp; (E lógico), ! (NÃO lógico). Esses são operadores não vetorizados. Versões vetorizadas serão abordadas no decorrer do curso. Revise as estruturas de condições: if, else, switch, ifelse. A função ifelse equivale à estrutura (condição) ? retorno 1 : retorno 2 das linguagens C/C++; Revise as estruturas de repetições: while, for e repeat. Entenda o uso das instruções break e next quando utilizadas dentro dessas estruturas. Revise a construção de funções em R. Tente entender a flexibilidade embutida em funções que retornam uma lista. Se achar necessário, revise algumas funções úteis: ls(), rm(), length(), sum(), abs(), mean(), median(), var(), sd(), cor(), summary(), sqrt(), exp(), expm1() (fornece uma boa proximação para exp(x) - 1, quando x é pequeno), log(), log10(), log1p() (fornece uma boa aproximação para log(x+1) quando x é pequeno), round(), union(), intersect(), choose(), factorial(), dim(), ncol(), nrow(), diag(), %*%, t(), solve(), det(), eigen(), print(), cat(), paste(), paste0(), substring(),str(), sort(), quantile(), match() e %in%. Lembre-se que quando os operadores +, -, *, /, %% (módulo / resto da divisão) e ^ são aplicados ente matrizes, ou entre matrizes e vetores de comprimento 1 (“constantes”), as operações serão realizadas elemento à elemento. Diversas outras características da linguagem R são importantes e serão lembradas aos poucos na medida que for necessário. Ficará a cargo do leitor fazer as sugestões de revisões acima. O capítulo que inicia esse material é dedicado à apresentação de exercício em que o leitor deverá resolver. Trata-se de um capítulo em que os exercícios envolvem as sugestões de revisão da linguagem R apresentadas acima. Os exercícios para serem resolvidos poderão exigir revisões de outros conceitos que não foram listados na proposta de revisão acima. No entanto, se esses exercícios forem bem resolvidos, utilizando-se de boas práticas de programação em R, a leitura desse material será a mais agradável possível. "],
["exercicios-para-uma-revisao-da-linguagem-r.html", "1 Exercícios para uma revisão da linguagem R Exercícios propostos", " 1 Exercícios para uma revisão da linguagem R Mesmo que você se considere um programador razoável de R, aconselho que venha resolver a lista de exercícios apresentada adiante. É comum que venhamos esquecer de alguns conceitos de linguagens em que programamos. Esses exercícios é uma oportunidade que você irá ter de revisar lógica de programação utilizando a linguagem R e consequentemente revisar alguns conceitos importantes da linguagem. Tente fazer esses exercícos após um olhar detalhado das sugestões apresentadas. As sugestões de revisão sugerem temas bastante simples para quem já programa um pouco na linguagem R. Tais sugestões aliadas com as resoluções desses exercício irão lapidar os conhecimentos necessários e fará com que você necessariamente revise outros assuntos inseridos nos exercícios. Observação: A google disponibilizou um guia de estilo de programação em R. Trata-se de um guia de boas práticas de programação no que diz respeito à escrita do código. Esse guia não trata de boas práticas de programação para a obtenção de melhorias de desempenho da linuguagem R. Você não é obrigado adotar essas normas. Porém, segui-las tornará o seu código mais legível. Exercícios propostos Responda os itens abaixo: Descreva os principais tipos de dados de R. Descreva os principais estruturas de dados de R. Disserte sobre as diferenças entre tipos de dados e estruturas de dados. Descreva quais estruturas de dados são homogêneas e quais estruturas são heterogêneas. Explique o por quê das saídas abaixo: x &lt;- c(7.1, 2.3, 3L, TRUE) x ## [1] 7.1 2.3 3.0 1.0 y &lt;- c(TRUE, letters[1:3]) y ## [1] &quot;TRUE&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; z &lt;- c(1.0, 5, 7, 0L) z ## [1] 1 5 7 0 Sem utilizar o R, o que você espera como retorno de x &lt;- c(1, c(2, c(3, 4))); x. Qual a estrutura de dados de x? Irá ocorrer erro ao tentar criar um vetor atômico (vetor) com objetos de tipos diferentes? Como o interpretador de R trata essas situações. Explique detalhadamente. O que signicica NA, NaN, Inf e -Inf, em R? Liste algumas das situações em que utilizando-se das operações básicas +, -, * e / é possível ter como retorno NaN. Considere vetor &lt;- c(2, 7, 10, 8). Qual o tipo de dados do objeto vetor? Crie os objetos vetor_int, vetor_character e vetor_logical. (Dica: Crie esses objetos fazendo a conversão do objeto vetor). O que faz o código abaixo? Explique detalhadamente o que cada função faz. objects(grep(&quot;bas&quot;, search())) Explique passo a passo a sintaxe abaixo: search()[(grep(&quot;gr&quot;, search()))] Forneça o código que acessa o caracter \"a\" de l, em que l &lt;- c(list(c(3, 2), \"a\"), c(1,2)). Depois, converta l em um vetor atômico. Sem correr os códigos abaixo, descreva as saídas obtidas: Qual a saída esperada para os códigos c(1, FALSE), c(“a”, 1), c(list(1), “a”), c(TRUE, 1L)? Por que 1 == \"1\" é igual à TRUE? Por que -1 &lt; FALSE é igual à TRUE? Considere vetor &lt;- 1:25. Com no objeto vetor, construa uma matriz de dimensão 5x5 usando a função matrix() e dois utilizando a função dim(). Crie a matriz M, de dimensão 50x50, com elementos de 1 à 2500 preenchidos por linha. Atribua nomes às linhas (l_1 à l_50) e colunas (c_1 à c_50) da matriz. (Dica: certamente você percebeu que não é nada interessante digitar elemento por elemento para as linhas e colunas da matriz. Tente utilizar as funções paste() e rep()como soluções para o problema). Remova os nomes das linhas e colunas da matriz M criada no exercício anterior. Sejam V1 &lt;- matrix(1:12, ncol = 4, nrow = 3) e W1 &lt;- matrix(1:8, ncol = 4, nrow = 2). Crie a matriz M1que é o resultado da concatenação por linha de V1 e W1. Considere os objetos V2 &lt;- matrix(1:12, ncol = 2, nrow = 4) e W2 &lt;- matrix(1:12, ncol = 3, nrow = 4). Cria a matriz M2como resultados da concatenação por coluna de V2 e W2. Considere obj &lt;- list(1:3, \"a\" , TRUE, 1.0). Construa uma matriz de dimensão 2x2 a partir de obj. Construa uma matriz de avaliações A a de dimensão 30x2, em que a primeira coluna são os nomes dos alunos (Aluno_1 à Aluno_30) e a segunda coluna são as notas de 3 avaliações, por aluno. Dica: Para facilitar, gere as avaliações dos alunos de forma aleatória. O que a função dim() retorna quando aplicada à um vetor? Se is.matrix(x) retorna TRUE, o que irá retornar de is.array(x)? Descreva os objetos objetos x1, x2 e x3. x1 &lt;- array(1:5, c(1, 1, 5)) x2 &lt;- array(1:5, c(1, 5, 1)) x3 &lt;- array(1:5, c(5, 1, 1)) Considere o código código abaixo: df &lt;- data.frame(x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df$y ## [1] a b c ## Levels: a b c Como podemos observar, df$y retorna um fator com os níveis construídos das strings que compõe a variável y. Como podemos alterar o comportamento do data frame df para que df$y retorne um vetor atômico do tipo character? Corrija o código abaixo de modo a que venha funcionar: data.frame(x = 1:3, y = list(1:2, 1:3, 1:4)) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 2, 3, 4 Considere a lista abaixo: notas &lt;- list(c(7.1, 3.2, NA), c(2.7, 8.8, 10.0), c(0.0, NA, NA), c(7.7, 8.4, 6.3), c(3.6, 6.6, 8.1), c(NA, NA, NA), c(7.4, 7.1, 7.3), c(10.0, NA, 7.0), c(1.6, 3.2, 5.3), c(8.8, 9.2, 8.0)) Responta os itens abaixo: Atribua nomes (Aluno_1 à Aluno_10) à cada elemento de notas. Crie o vetor status contendo o status dos dez alunos. Considere: A (aprovado), REP (reprovado), F (final). (Dica: Construa o vetor status atribuindo literalmente as categorias A, REP ou F para cada aluno, ou seja, não é preciso criar uma função para fazer isso automaticamente. Considere A para os alunos com média no intervalo \\([7, 10]\\), R para os alunos com média no intervalo \\([0, 4)\\) e F para os alunos com média no intervalo \\([4, 7)\\)). Crie o vetor alunos com os nomes dos alunos. Construa o data frame historico com as variáveis nomes, notas e status. Com base no data frame historico, construa o data frame aprovados com os alunos aprovados. De forma análoga para os demais status. Suponha que o professor está interessado em saber quais alunos foram ou tem alguma chance de assumir o status de aprovado. Construa o data frame bons_alunos com estes alunos. Modifique os nomes das linhas do data frame historico colocando id_1 na primeira linha e respectivamente, no mesmo padrão, para as demais linhas. Obtenha por meio do data frame historico um novo data frame (historico_na) com os alunos que deixaram ao menos uma prova para repor. Apenas para os alunos que fizeram as três avaliações, obtenha uma média aritmética das avaliações. Acrescente a variável de nome media no data frame historico. Consideremos o conjunto de dados state.x77 do pacote datasets (pacote padrão de R). A base state.x77 refere-se à uma matriz de dimensão 50x8 em que cada linha refere-se à um dos 50 estados dos EUA. Consulte as documentações para obter maiores informações. Responda os itens abaixo: Construa o data frame dados utilizando state.x77. Obtenha um data frame de nome dados_1 com as observações de dados que possua população maior que 4246, isto é, com os estados estadunidenses que possua uma população maior que 4246 (quatro milhões duzentos e quarenta e seis mil). Obtenha o data frame dados_2 com as observações população maior que 4246 e menores que 8 milhões, isto é, menor que 8000. Obtenha o vetor vetor_est com os nomes dos estados que obedecem os critérios do item 3. Construa o data frame dados_3 com os estados estadunidenses com população maior que 1.5 vezes a média dos 50 estados considerados. Obtenha o vetor com o nome dos estados que obedecem essa regra. Construa o data frame dados_4 com os estados estadunidenses com população maior que duas vezes a mediana dos 50 estados e que tenha uma população com expectativa de vida maior que 71.84 anos. Obtenha o data frame dados_5 com os estados estadunidenses com renda maior que a média nacional, expectativa de vida maior que 72 anos. Adicione ao data frame dados duas linhas com a média de todas as variáveis e variâncias, respectivamente. Escreva uma função que retorne o imposto pago por mulheres e por homens, sabendo que as mulheres pagam \\(10%\\) e que os homens pagam \\(5%\\) a mais do que as mulheres. Resolva o exercício anterior utilizando a função switch(). Escreva a função celtofar() que converte um vetor de temperaturas em graus Celsius para graus Fahrenheit. Considere: \\[F = 1.8 * C + 32,\\] em que \\(C\\) é a temperatura em graus Celsius e \\(F\\) é a temperatura em graus Fahrenheit. Melhore a função celtofar() para que critique valores não válidos de temperatura. Modifique a função celtofar() para que funcione também para conversões no sentido oposto, isto é, converta de graus Fahrenheit para graus Celsius. Construa a função imc() que calcula o IMC (Índice de Massa Corporal) de uma pessoa. A função deverá retornar o IMC e um status. Observe que: \\[\\mathrm{IMC} = \\frac{\\mathrm{peso}}{\\mathrm{altura}^2},\\] em que \\(\\mathrm{peso}\\) é dado em \\(kg\\) e a \\(\\mathrm{altura}\\) é fornecida em \\(cm\\). Alem disso, considere: IMC Status \\(&lt; 17.0\\) Muito abaixo do peso \\([17.0; 18.5)\\) Abaixo do peso \\([18.5; 25.0)\\) Peso normal \\([25.0; 30.0)\\) Acima do peso \\([30.0; 35.0)\\) Obesidade nível I \\([35.0; 40.0)\\) Obesidade nível II (severa) \\(\\geq 40.0\\) Obesidade nível III (mórbida) Dica: Uma função robusta deverá tratar problemas com a entrada, isto é, deverá criticar informações inconsistentes passadas como argumento. Escreva um programa que retorne a saída baixo: i1 = 1 i2 = 2 i3 = 3 i4 = 4 i5 = 5 i6 = 6 i7 = 7 Dica: Resolva esse simples exercício de três formas diferentes (usando while, for e repeat). Utilizando a instrução de repetição for construa um pequeno programa que com base em um vetor de valores no intervalo \\([0, 1]\\), some apenas os valores maiores que 0.7. Dica: Para economizar tempo, faça vetor &lt;- runif(n = 1e5, min = 0, max = 1) para gerar o objeto vetor. Resolva o exercício 28 sem utilizar nenhuma instrução de repetição. Avalie o custo computacional dos exercícios anteriores (exercícios 28 e 29) utilizando a função Sys.time(). Discuta o resultado. Construa duas funções que escrevam as imagens abaixo, respectivamente. O programa deverá utilizar instruções de laço de resolver o problema. A primeira função deverá imprimir: ********** ********* ******** ******* ****** ***** **** *** ** * A segunda função deverá imprimir: *-*-*-*-*- *-*-*-*-* *-*-*-*- *-*-*-* *-*-*- *-*-* *-*- *-* *- * Escreva um programa em R, utilizando as instruções de loop vistas anteriormente, de modo a fornecer as seguintes estruturas, adepender do valor de n. Para \\(n = 1\\): * Para \\(n = 2\\): * ** Para \\(n = 3\\): * ** *** e assim por diante para outros valores de \\(n\\). Dica: crie uma função tree() que tenha n como argumento. Resolva o exercício anterior acrescentando mais um argumento à função tree() para que seja possível especificar outro caracter além de *. Modifique o programa da solução do exercício 31, de tal forma que a estrutura obtida seja: Para \\(n = 1\\): A Para \\(n = 2\\): A BB Para \\(n = 3\\): A BB CCC e assim por diante para outros valores de \\(n\\). Dica: Note que \\(n \\leq 26\\). Assim, retorne uma mensagem de advertência se um valor de \\(n\\) inapropriado for informado. Por exemplo, utilize a função stop(). Implemente a função aprox_e() que retorna uma aproximação para \\(\\mathrm{e}^x\\) considerando: \\[\\mathrm{e}^x = \\sum_{n = 0}^{\\infty} \\frac{x^n}{n!}.\\] Dica: A função aprox_e() deverá receber um argumento em que será utilizado como o número de termos somados. Crie a função aprox_pi(), fazendo uso de instruções de repetição, que implemente a aproximação abaixo para o valor da constante \\(\\pi\\): \\[\\pi = 4 - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\frac{4}{9} - \\frac{4}{11} + \\dots\\] Dica: Premita que o usuário de sua função forneça a quantidade de termos a ser considerado na soma. Além disso, faça com que sua função critique valores indevidos para a quantidade de termos somados. Implemente a função fib(), utilizando instruções de repetição, que retorna o Fibonacci de um número. Lembre-se, a sequência de Fibonacci é dada por \\(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\ldots\\) . Note que Fibonacci de \\(n\\) é dado por \\(F_n = F_{n-1} + F_{n-2},\\, n &gt; 2\\), com \\(F_1 = 1\\) e \\(F_2 = 1\\). Por exemplo, Fibonacci de 5 é dado por \\(F_5 = F_{4} + F_{3} = 3 + 2 = 5\\). Implemente o exercício anterior usando funções recursivas. Lembre-se: chamamos de funções recursivas a função que chama a si mesma. Um esboço: func_f &lt;- function(...){ # Ué? ... # Sim! Estamos chamando a função que estamos criando. ;) func_f(...) # É preciso para em algum momento # somos finitos :) if (contition) break } Implemente a função aprox_pi() de forma recursiva. Implementa a função nachange(df), em que df recebe um data frame / matriz. A função nachange() deverá trocar NA pelo character “?”. Dica: Em caso de df não possuir nenhum elemento NA, a função nachange() deverá retornar o objeto passado para df. Construa a função searchindf(df, value), em que df é um data frame / matriz e value é um vetor de uma única posição. A função searchindf()deverá retorna TRUE se o valor passado para value é encontrado em alguma posição do data frame passado para df e FALSE caso contrário. Dica: Tente construir a função de forma mais robusta possível. Por exemplo, considere criticar os argumentos caso estes não sejam de estrutura de dados correta. Você não poderá utilizar funções já implementadas em R para esse finalidade. Construa a função namecolsort(df), em que df recebe como argumento um data frame/matriz. A função namecolsort() deverá retorna o data frame / matriz com as colunas ordenadas. Dica: Ordene as colunas considerando o primeiro caracter do nome da coluna. Escreva a função exclusive(df), em que dfrecebe como argumento um data frame/matriz. A função exclusive() deverá retornar a posição das linhas exclusivas, ou seja, as linhas que não possuem elementos repetidos. Escreva uma função extremeindex(df, max = TRUE), em que dfrecebe como primeiro argumento um data frame/matriz. A função maxindex() deverá retornar a posição (linha, coluna) do valor máximo no objeto passado para df, caso max = TRUE. Em caso de max = FALSE, a função maxindex() deverá retornar a posição (linha, coluna) do valor mínimo no objeto passado para df. Dica: A função maxindex() deverá retornar um vetor em que o primeiro elemento refere-se à linha e o segundo informa a coluna do elemento encontrado (máximo/mínimo). Implemente a função myt(df), em que dfrecebe como argumento um data frame/matriz. A função myt() deverá girar em 90 graus a matriz/data frame passado para df. Dica: Não utilize a função t() para transpor uma matriz. "],
["evangelizando-para-o-uso-do-linux.html", "2 Evangelizando para o uso do Linux", " 2 Evangelizando para o uso do Linux "],
["utilizando-melhor-o-rstudio.html", "3 Utilizando melhor o RStudio", " 3 Utilizando melhor o RStudio "]
]
