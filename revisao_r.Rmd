# Exercícios para uma revisão da linguagem R 

Mesmo que você se considere um programador razoável de [**R**](https://www.r-project.org/about.html), aconselho que venha resolver a lista de exercícios apresentada adiante. É comum que venhamos esquecer de alguns conceitos de linguagens em que programamos. Esses exercícios é uma oportunidade que você irá ter de revisar lógica de programação utilizando a linguagem [**R**](https://www.r-project.org/about.html) e consequentemente revisar alguns conceitos importantes da linguagem. Tente fazer esses exercícos após um olhar detalhado das [sugestões][Sugestões de passos para revisão da linguagem R] apresentadas. 

As [sugestões de revisão][Sugestões de passos para revisão da linguagem R] sugerem temas bastante simples para quem já programa  um pouco na linguagem [**R**](https://www.r-project.org/about.html). Tais sugestões aliadas com as resoluções desses exercício irão lapidar os conhecimentos necessários e fará com que você necessariamente revise outros assuntos inseridos nos exercícios.

**Observação**:

```{block2, type='rmdobservation'}
<div class=text-justify>
A google disponibilizou um [guia de estilo](https://google.github.io/styleguide/Rguide.xml) de programação em [**R**](https://www.r-project.org/about.html). Trata-se de um guia de boas práticas de programação no que diz respeito à escrita do código. Esse guia **não** trata de boas práticas de programação para a obtenção de melhorias de desempenho da linuguagem [**R**](https://www.r-project.org/about.html).

**Você não é obrigado adotar essas normas. Porém, segui-las tornará o seu código mais legível.**

</div>
```


-----

## Exercícios propostos {-}

1. Responda os itens abaixo:



    1. Descreva os principais tipos de dados de R.
    2. Descreva os principais estruturas de dados de R.
    3. Disserte sobre as diferenças entre tipos de dados e estruturas de dados.
    4. Descreva quais estruturas de dados são homogêneas e quais estruturas são heterogêneas.


2. Explique o por quê das saídas abaixo:

    ```{r}
    x <- c(7.1, 2.3, 3L, TRUE)
    x

    y <- c(TRUE, letters[1:3])
    y

    z <- c(1.0, 5, 7, 0L)
    z
    ```

3. Sem utilizar o R, o que você espera como retorno de `x <- c(1, c(2, c(3, 4))); x`. Qual a estrutura de dados de `x`?


4. Irá ocorrer erro ao tentar criar um vetor atômico (vetor) com objetos de tipos diferentes? Como o interpretador de R trata essas situações. Explique detalhadamente.

5. O que signicica `NA`, `NaN`, `Inf` e `-Inf`, em R? Liste algumas das situações em que utilizando-se das operações básicas `+`, `-`, `*` e `/` é possível ter como retorno `NaN`.

6. Considere `vetor <- c(2, 7, 10, 8)`. Qual o tipo de dados do objeto `vetor`? Crie os objetos `vetor_int`, `vetor_character` e `vetor_logical`. (**Dica**: Crie esses objetos fazendo a conversão do objeto `vetor`).


7. O que faz o código abaixo? Explique detalhadamente o que cada função faz.

    ```r
    objects(grep("bas", search()))
    ```

8. Explique passo a passo a sintaxe abaixo:

    ```r
    search()[(grep("gr", search()))]
    ```

9. Forneça o código que acessa o caracter `"a"` de `l`, em que `l <- c(list(c(3, 2), "a"), c(1,2))`. Depois, converta `l` em um vetor atômico.

10. Sem correr os códigos abaixo, descreva as saídas obtidas:

    1. Qual a saída esperada para os códigos c(1, FALSE), c("a", 1), c(list(1), "a"), c(TRUE, 1L)?
  
    2. Por que `1 == "1"` é igual à `TRUE`?
  
    3. Por que `-1 < FALSE` é igual à `TRUE`?
  
11. Considere `vetor <- 1:25`. Com no objeto `vetor`, construa uma matriz de dimensão 5x5 usando a função `matrix()` e dois utilizando a função `dim()`.

12. Crie a matriz `M`, de dimensão 50x50, com elementos de 1 à 2500 preenchidos por linha. Atribua nomes às linhas (**l_1** à **l_50**) e colunas (**c_1** à **c_50**) da matriz. (**Dica**: certamente você percebeu que não é nada interessante digitar elemento por elemento para as linhas e colunas da matriz. Tente utilizar as funções `paste()` e  `rep()`como soluções para o problema).

13. Remova os nomes das linhas e colunas da matriz `M` criada no exercício anterior.

14. Sejam `V1 <- matrix(1:12, ncol = 4, nrow = 3)` e `W1 <- matrix(1:8, ncol = 4, nrow = 2)`. Crie a matriz `M1`que é o resultado da concatenação por linha de `V1` e `W1`.

15. Considere os objetos `V2 <- matrix(1:12, ncol = 2, nrow = 4)` e `W2 <- matrix(1:12, ncol = 3, nrow = 4)`. Cria a matriz `M2`como resultados da concatenação por coluna de `V2` e `W2`.

16. Considere `obj <- list(1:3, "a" , TRUE, 1.0)`. Construa uma matriz de dimensão 2x2 a partir de `obj`.

17. Construa uma matriz de avaliações `A` a de dimensão 30x2, em que a primeira coluna são os nomes dos alunos (**Aluno_1** à **Aluno_30**) e a segunda coluna são as notas de 3 avaliações, por aluno. **Dica**: Para facilitar, gere as avaliações dos alunos de forma aleatória.

18. O que a função `dim()` retorna quando aplicada à um vetor?

19. Se `is.matrix(x)` retorna `TRUE`, o que irá retornar de `is.array(x)`?

20. Descreva os objetos objetos `x1`, `x2` e `x3`. 
    
    ```r
    x1 <- array(1:5, c(1, 1, 5))
    x2 <- array(1:5, c(1, 5, 1))
    x3 <- array(1:5, c(5, 1, 1))
    ```

21. Considere o código código abaixo:

    ```{r}
    df <- data.frame(x = 1:3, y = c("a", "b", "c"))
    df$y
    ```
    Como podemos observar, `df$y` retorna um fator com os níveis construídos das strings que compõe a variável `y`. Como           podemos alterar o comportamento do data frame `df` para que `df$y` retorne um vetor atômico do tipo character?

22. Corrija o código abaixo de modo a que venha funcionar:

    ```{r, error = TRUE}
    data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
    ```

23. Considere a lista abaixo:

    ```r
    notas <- list(c(7.1, 3.2, NA), c(2.7, 8.8, 10.0),
                  c(0.0, NA, NA), c(7.7, 8.4, 6.3),
                  c(3.6, 6.6, 8.1), c(NA, NA, NA),
                  c(7.4, 7.1, 7.3), c(10.0, NA, 7.0),
                  c(1.6, 3.2, 5.3), c(8.8, 9.2, 8.0))
    ```

    Responta os itens abaixo:


    1. Atribua nomes (**Aluno_1** à **Aluno_10**) à cada elemento de `notas`.
  
    2. Crie o vetor `status` contendo o status dos dez alunos. Considere: **A** (aprovado), **REP** (reprovado), **F** (final). (**Dica**: Construa o vetor `status` atribuindo literalmente as categorias **A**, **REP** ou **F** para cada aluno, ou seja, não é preciso criar uma função para fazer isso automaticamente. Considere **A** para os alunos com média no intervalo $[7, 10]$, **R** para os alunos com média no intervalo $[0, 4)$ e **F** para os alunos com média no intervalo $[4, 7)$).
  
    3. Crie o vetor `alunos` com os nomes dos alunos.
  
    4. Construa o data frame `historico` com as variáveis **nomes**, **notas** e **status**. 
  
    5. Com base no data frame `historico`, construa o data frame `aprovados` com os alunos aprovados. De forma análoga para os demais status. 
  
    6. Suponha que o professor está interessado em saber quais alunos foram ou tem alguma chance de assumir o status de aprovado. Construa o data frame `bons_alunos` com estes alunos.
  
    7. Modifique os nomes das linhas do data frame historico colocando **id_1** na primeira linha e respectivamente, no mesmo padrão, para as demais linhas. 
  
    8. Obtenha por meio do data frame `historico` um novo data frame (`historico_na`) com os alunos que deixaram ao menos uma prova para repor.
  
    9. Apenas para os alunos que fizeram as três avaliações, obtenha uma média aritmética das avaliações. Acrescente a variável de nome **media** no data frame `historico`.
  
24. Consideremos o conjunto de dados `state.x77` do pacote **datasets** (pacote padrão de R). A base  `state.x77` refere-se à uma matriz de dimensão 50x8 em que cada linha refere-se à um dos 50 estados dos EUA. Consulte as documentações para obter maiores informações.

    Responda os itens abaixo:

    1. Construa o data frame `dados` utilizando `state.x77`.

    2. Obtenha um data frame de nome `dados_1` com as observações de dados que possua população maior que 4246, isto é, com os estados estadunidenses que possua uma população maior que 4246 (quatro milhões duzentos e quarenta e seis mil). 
  
    3. Obtenha o data frame `dados_2` com as observações população maior que 4246 e menores que 8 milhões, isto é, menor que 8000.
  
    4. Obtenha o vetor `vetor_est` com os nomes dos estados que obedecem os critérios do item 3.
  
    5. Construa o data frame `dados_3` com os estados estadunidenses com população maior que 1.5 vezes a média dos 50 estados considerados. Obtenha o vetor com o nome dos estados que obedecem essa regra.

    6. Construa o data frame `dados_4` com os estados estadunidenses com população maior que duas vezes a mediana dos 50 estados e que tenha uma população com expectativa de vida maior que 71.84 anos.
  
    7. Obtenha o data frame `dados_5` com os estados estadunidenses com renda maior que a média nacional, expectativa de vida maior que 72 anos.
  
    8. Adicione ao data frame dados duas linhas com a média de todas as variáveis e variâncias, respectivamente.
  
25. Escreva uma função que retorne o imposto pago por mulheres e por homens, sabendo que as mulheres pagam $10%$ e que os homens pagam $5%$ a mais do que as mulheres.

26. Resolva o exercício anterior utilizando a função `switch()`.

27. Escreva a função `celtofar()` que converte um vetor de temperaturas em graus Celsius para graus Fahrenheit. Considere:

$$F = 1.8 * C + 32,$$
    em que $C$ é a temperatura em graus Celsius e $F$ é a temperatura em graus Fahrenheit. 

28. Melhore a função `celtofar()` para que critique valores não válidos de temperatura.

29. Modifique a função `celtofar()` para que funcione também para conversões no sentido oposto, isto é, converta de graus Fahrenheit para graus Celsius.

30. Construa a função `imc()` que calcula o IMC (Índice de Massa Corporal) de uma pessoa. A função deverá retornar o IMC e um status. Observe que: 

    $$\mathrm{IMC} = \frac{\mathrm{peso}}{\mathrm{altura}^2},$$
    em que $\mathrm{peso}$ é dado em $kg$ e a $\mathrm{altura}$ é fornecida em $cm$.

    Alem disso, considere:

    -------------------------------------------------
    IMC               Status        
    ---------------   -------------------------------
    $< 17.0$          Muito abaixo do peso

    $[17.0; 18.5)$    Abaixo do peso

    $[18.5; 25.0)$    Peso normal

    $[25.0; 30.0)$    Acima do peso

    $[30.0; 35.0)$    Obesidade nível I

    $[35.0; 40.0)$    Obesidade nível II (severa)

    $\geq 40.0$       Obesidade nível III (mórbida)
    -------------------------------------------------

    **Dica**: Uma função robusta deverá tratar problemas com a entrada, isto é, deverá criticar informações inconsistentes passadas como argumento.

27. Escreva um programa que retorne a saída baixo:

    ```r
    i1 = 1
    i2 = 2 
    i3 = 3
    i4 = 4
    i5 = 5
    i6 = 6
    i7 = 7
    ```

    **Dica**: Resolva esse simples exercício de três formas diferentes (usando `while`, `for` e `repeat`).

28. Utilizando a instrução de repetição `for` construa um pequeno programa que com base em um vetor de valores no intervalo
$[0, 1]$, some apenas os valores maiores que 0.7. **Dica**: Para economizar tempo, faça `vetor <- runif(n = 1e5, min = 0, max = 1)` para gerar o objeto `vetor`.

29. Resolva o exercício 28 sem utilizar nenhuma instrução de repetição.

30. Avalie o custo computacional dos exercícios anteriores (exercícios 28 e 29) utilizando a função `Sys.time()`. Discuta o resultado.

31. Construa duas funções que escrevam as imagens abaixo, respectivamente. O programa deverá utilizar instruções de laço de resolver o problema.

    **A primeira função deverá imprimir**:

    ```
    **********
    *********
    ********
    *******
    ******
    *****
    ****
    ***
    **
    *
    ```

    **A segunda função deverá imprimir**: 

    ```
    *-*-*-*-*-
    *-*-*-*-*
    *-*-*-*-
    *-*-*-*
    *-*-*-
    *-*-*
    *-*-
    *-*
    *-
    *
    ```

32. Escreva um programa em R, utilizando as instruções de loop vistas anteriormente, de modo a fornecer as seguintes estruturas, adepender do valor de `n`.


    Para $n = 1$:

        
        *            
        

    Para $n = 2$:

        
        * 
        **
        

    Para $n = 3$:

        
        *
        **
        ***
        
    e assim por diante para outros valores de $n$. **Dica**: crie uma função `tree()` que tenha `n` como argumento.

33. Resolva o exercício anterior acrescentando mais um argumento à função `tree()` para que seja possível especificar outro caracter além de `*`. 

34. Modifique o programa da solução do exercício 31, de tal forma que a estrutura obtida seja:

    Para $n = 1$:

    ```
    A            
    ```

    Para $n = 2$:

    ```
    A 
    BB
    ```
 
    Para $n = 3$:

    ```
    A
    BB
    CCC
    ```
    e assim por diante para outros valores de $n$. **Dica**: Note que $n \leq 26$. Assim, retorne uma mensagem de advertência se um valor de $n$ inapropriado for informado. Por exemplo, utilize a função `stop()`.

35. Implemente a função `aprox_e()` que retorna uma aproximação para $\mathrm{e}^x$ considerando:

    $$\mathrm{e}^x = \sum_{n = 0}^{\infty} \frac{x^n}{n!}.$$
    **Dica**: A função `aprox_e()` deverá receber um argumento em que será utilizado como o número de termos somados.


36. Crie a função `aprox_pi()`, fazendo uso de instruções de repetição, que implemente a aproximação abaixo para o valor da constante $\pi$:

    $$\pi = 4 - \frac{4}{3} + \frac{4}{5} - \frac{4}{7} + \frac{4}{9} - \frac{4}{11} + \dots$$

    **Dica**: Premita que o usuário de sua função forneça a quantidade de termos a ser considerado na soma. Além disso, faça       com que sua função critique valores indevidos para a quantidade de termos somados. 

37. Implemente a função `fib()`, utilizando instruções de repetição, que retorna o Fibonacci de um número. Lembre-se, a sequência de Fibonacci é dada por $1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \ldots$ . Note que Fibonacci de $n$ é dado por $F_n = F_{n-1} + F_{n-2},\, n > 2$, com $F_1 = 1$ e $F_2 = 1$. Por exemplo, Fibonacci de 5 é dado por $F_5 = F_{4} + F_{3} = 3 + 2 = 5$.

38. Implemente o exercício anterior usando funções recursivas. **Lembre-se**: chamamos de funções recursivas a função que chama a si mesma.

    **Um esboço**:

    ```r
    func_f <- function(...){
        
       # Ué? ...
       # Sim! Estamos chamando a função que estamos criando. ;)
       func_f(...)
        
       # É preciso para em algum momento
       # somos finitos :)
       if (contition) break 
    }
    ```

39. Implemente a função `aprox_pi()` de forma recursiva.


40. Implementa a função `nachange(df)`, em que `df` recebe um data frame / matriz. A função `nachange()` deverá trocar `NA` pelo character "?". **Dica**: Em caso de `df` não possuir nenhum elemento `NA`, a função `nachange()` deverá retornar o objeto passado para `df`. 

39. Construa a função `searchindf(df, value)`, em que `df` é um data frame / matriz e `value` é um vetor de uma única posição. A função `searchindf()`deverá retorna **TRUE** se o valor passado para `value` é encontrado em alguma posição do data frame passado para `df` e **FALSE** caso contrário. **Dica**: Tente construir a função de forma mais robusta possível. Por exemplo, considere criticar os argumentos caso estes não sejam de estrutura de dados correta. **Você não poderá utilizar funções já implementadas em R para esse finalidade**.

40. Construa a função `namecolsort(df)`, em que `df` recebe como argumento um data frame/matriz. A função `namecolsort()` deverá retorna o data frame / matriz com as colunas ordenadas. **Dica**: Ordene as colunas considerando o primeiro caracter do nome da coluna.
    

41. Escreva a função `exclusive(df)`, em que `df`recebe como argumento um data frame/matriz. A função `exclusive()` deverá retornar a posição das linhas exclusivas, ou seja, as linhas que não possuem elementos repetidos.

42. Escreva uma função `extremeindex(df, max = TRUE)`, em que `df`recebe como primeiro argumento um data frame/matriz. A função `maxindex()` deverá retornar a posição (linha, coluna) do valor máximo no objeto passado para `df`, caso `max = TRUE`. Em caso de `max = FALSE`,  a função `maxindex()` deverá retornar a posição (linha, coluna) do valor mínimo no objeto passado para `df`. **Dica**: A função `maxindex()` deverá retornar um vetor em que o primeiro elemento refere-se à linha e o segundo informa a coluna do elemento encontrado (máximo/mínimo).

43. Implemente a função `myt(df)`, em que `df`recebe como argumento um data frame/matriz. A função `myt()` deverá girar em 90 graus a matriz/data frame passado para `df`. **Dica**: Não utilize a função `t()` para transpor uma matriz.

44. Crie a função `anagram(x, y)` que recebe dois argumentos (duas strings). A função `anagram()` deverá retornar **TRUE** se uma palavra (string) é anagrama da outra e **FALSE** em situação contrária. A função deverá considerar que ambas as strings possui a mesma quantidade de caracteres. Caso a quantidade de caracteres não seja igual em ambas as strings, a função deverá parar e advertir o usuário. **Dica**: Você poderá utilizar a função `strsplit()`. 

45. Implemente a função `strposition(x)` que dado uma palavra (string) fromada por letras do alfabeto Romano e passada como argumento para `x`, retorne a posição das letras em um vetor. Por exemplo, a string (palavra) **cada** passada para a função fará com que `strposition()` retorne o vetor formados pelos elementos 3, 1, 4 e 1. **Dica**: A função **não** poderá aceitar strings que são formadas por pelo menos um caracter que não seja uma letra do alfabeto Romano.

46. Altere a função `strposition(x)` para que em situação da string possuir um ou mais caracteres não pertencentes ao alfabeto Romano, o retono seja`NA`, nas respectivas posições destes caracteres.